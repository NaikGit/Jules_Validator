package com.example.validation_service.service;

import com.example.validation_service.dto.Payee;
import com.example.validation_service.dto.Payer;
import com.example.validation_service.dto.RawPaymentData;
import com.example.validation_service.dto.ValidatedPayment;
import com.example.validation_service.mapper.PaymentMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mapstruct.factory.Mappers;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.Spy;
import org.mockito.junit.jupiter.MockitoExtension;

import java.math.BigDecimal;
import java.time.Instant;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class PaymentTransformerServiceTest {

    // We will spy on the real mapper to allow actual mapping logic to run,
    // but also to be able to mock parts of it if needed (e.g., Instant.now()).
    // However, for direct testing of MapStruct, usually you let it do its work.
    // Here, we'll inject the real mapper instance generated by MapStruct.
    @Spy
    private PaymentMapper paymentMapper = Mappers.getMapper(PaymentMapper.class);

    @InjectMocks
    private PaymentTransformerService paymentTransformerService;

    private RawPaymentData rawPaymentData;

    @BeforeEach
    void setUp() {
        rawPaymentData = new RawPaymentData(
                "MSGID001", "INSTRID001", "ENDTOEND001",
                "Debtor Name", "DEBTORID",
                "Creditor Name", "CREDITORID",
                "123.45", "USD"
        );
    }

    @Test
    void testTransform_Success() throws TransformationException {
        Instant expectedTimestamp = Instant.parse("2023-10-27T10:00:00Z");
        try (MockedStatic<Instant> mockedInstant = Mockito.mockStatic(Instant.class, Mockito.CALLS_REAL_METHODS)) {
            mockedInstant.when(Instant::now).thenReturn(expectedTimestamp);

            ValidatedPayment result = paymentTransformerService.transform(rawPaymentData);

            assertNotNull(result);
            assertEquals("MSGID001", result.getTransactionId());
            assertEquals("INSTRID001", result.getInstructionId());
            assertEquals("Debtor Name", result.getPayer().getName());
            assertEquals("DEBTORID", result.getPayer().getId());
            assertEquals("Creditor Name", result.getPayee().getName());
            assertEquals("CREDITORID", result.getPayee().getId());
            assertEquals(new BigDecimal("123.45"), result.getAmount());
            assertEquals("USD", result.getCurrency());
            assertEquals(expectedTimestamp, result.getTimestamp());
        }
    }

    @Test
    void testTransform_AmountConversion_CorrectBigDecimal() throws TransformationException {
        rawPaymentData.setAmount("9999.99");
        ValidatedPayment result = paymentTransformerService.transform(rawPaymentData);
        assertEquals(new BigDecimal("9999.99"), result.getAmount());

        rawPaymentData.setAmount("777"); // Whole number
        result = paymentTransformerService.transform(rawPaymentData);
        assertEquals(new BigDecimal("777"), result.getAmount());
    }

    @Test
    void testTransform_InvalidAmountFormat_ThrowsTransformationException() {
        rawPaymentData.setAmount("invalid-amount");
        // The PaymentMapper's stringToBigDecimal throws IllegalArgumentException
        // The PaymentTransformerService should catch this and wrap it in TransformationException.

        TransformationException exception = assertThrows(TransformationException.class, () -> {
            paymentTransformerService.transform(rawPaymentData);
        });
        assertTrue(exception.getMessage().contains("Error during data transformation: Invalid amount format: invalid-amount"));
        assertInstanceOf(IllegalArgumentException.class, exception.getCause());
    }

    @Test
    void testTransform_NullRawData_ThrowsTransformationException() {
        TransformationException exception = assertThrows(TransformationException.class, () -> {
            paymentTransformerService.transform(null);
        });
        assertEquals("Input RawPaymentData cannot be null.", exception.getMessage());
    }

    @Test
    void testTransform_NullFieldsInRawData_MappedAsNullOrDefaultsInValidatedPayment() throws TransformationException {
        // Set some fields to null that are directly mapped or used in custom methods
        rawPaymentData.setInstrId(null); // Directly mapped
        rawPaymentData.setDebtorName(null); // Used in mapPayer
        rawPaymentData.setCreditorId(null); // Used in mapPayee
        rawPaymentData.setAmount(null); // Amount is nullable, stringToBigDecimal returns null

        ValidatedPayment result = paymentTransformerService.transform(rawPaymentData);

        assertNull(result.getInstructionId());
        assertNotNull(result.getPayer()); // Payer object itself is created
        assertNull(result.getPayer().getName()); // Name within Payer is null
        assertEquals("DEBTORID", result.getPayer().getId()); // ID should still be there

        assertNotNull(result.getPayee()); // Payee object itself is created
        assertEquals("Creditor Name", result.getPayee().getName()); // Name should still be there
        assertNull(result.getPayee().getId()); // ID within Payee is null

        assertNull(result.getAmount()); // Amount should be null
    }
    
    @Test
    void testTransform_EmptyAmountString_ResultsInNullBigDecimal() throws TransformationException {
        rawPaymentData.setAmount(""); // Empty string
        ValidatedPayment result = paymentTransformerService.transform(rawPaymentData);
        assertNull(result.getAmount(), "Amount should be null when input string is empty, as per stringToBigDecimal logic in mapper.");
    }

    @Test
    void testTransform_UnexpectedMapperException_ThrowsTransformationException() {
        // To simulate an unexpected error from the mapper, we can't easily modify MapStruct's generated code.
        // Instead, we can mock the mapper to throw an exception for this specific test.
        // This requires not using @InjectMocks for paymentTransformerService for *this test method only*
        // or re-thinking how to inject a mock mapper.

        // Let's re-initialize service with a fully mocked mapper for this one test
        PaymentMapper mockMapper = Mockito.mock(PaymentMapper.class);
        PaymentTransformerService serviceWithMockMapper = new PaymentTransformerService(mockMapper);
        
        when(mockMapper.toValidatedPayment(any(RawPaymentData.class))).thenThrow(new RuntimeException("Unexpected mapper error"));

        TransformationException exception = assertThrows(TransformationException.class, () -> {
            serviceWithMockMapper.transform(rawPaymentData);
        });
        assertTrue(exception.getMessage().contains("An unexpected error occurred during data transformation"));
        assertInstanceOf(RuntimeException.class, exception.getCause());
        assertEquals("Unexpected mapper error", exception.getCause().getMessage());
    }
}
